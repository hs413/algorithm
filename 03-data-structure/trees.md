# 트리

- 부모와 자식 노드로 이루어진 비선형 데이터 구조
- 하나의 노드가 여러 노드를 가리킬 수 있다.
- 부모 자식 관계에 따라 자식 노드만 가리킬 수 있다.
  - 자식이 부모를 가리키거나 형제 노드를 가리킬 수 없다.
- 루트 노드는 하나만 있어야 한다.
 
### 주요 용어 
  - 루트: 시작 노드, 트리 맨 위에 있는 노드
  - 형제노드: 같은 부모를 가지는 노드
  - 리프노드: 자식이 없는 노드
  - 엣지(간선): 노드를 연결하는 선(화살표)

## [이진 탐색 트리 (BST)](src/main/java/trees/BinarySearchTree.java) - [Test](src/test/java/trees/BinarySearchTreeTest.java)
- 이진 트리의 특성 + 정렬된 데이터를 저장
- 부모 노드를 기준으로 왼쪽에 있는 자식 노드는 부모 보다 작은 값을 가짐
- 부모 노드를 기준으로 오른쪽에 있는 자식 노드는 부모 보다 큰 값을 가짐

### 이진 트리
- 모든 노드가 자식 노드를 최대 2개만 가질 수 있는 트리

### 이진트리 시간 복잡도
- 삽입 - O(log n)
- 탐색 - O(log n)
- 자식 노드가 부모 보다 크거나 작은 값만 있는 경우 O(n)이 나올 수도 있다.


## [트리 순회](src/main/java/trees/TreeTraversal.java) - [Test](src/test/java/trees/TreeTraversalTest.java)
- 일반적인 트리에서 노드를 찾기 위한 방법
  - 모든 노드를 순회해야 한다
- 너비 우선 탐색 (Breadth-first Search, BSF)
- 깊이 우선 탐색 (Depth-first Search, DFS)
  - 전위: 부모 노드를 먼저 탐색 
    - 부모 -> 왼쪽 -> 오른쪽
  - 중위: 부모 노드를 중간에 탐색
    - 왼쪽 -> 부모 -> 오른쪽
  - 중위: 부모 노드를 나중에 탐색
    - 왼쪽 -> 오른쪽 -> 부모

### BFS 
- 같은 레벨에 있는 노드를 먼저 탐색 (형제 노드를 먼저 탐색)
- 큐를 사용해 구현
  - 평균적으로 공간 복잡도가 DFS에 비해 높다
  
### DFS
- 재귀를 사용해 구현
- 평균적으로 공간 복잡도가 BFS에 비해 낮다

## [힙 (Heap)](src/main/java/trees/MaxBinaryHeap.java) - [Test](src/test/java/trees/MaxBinaryHeapTest.java)
- 완전 이진 트리를 기반으로 한 자료구조
- 최대 힙과 최소 힙이 있다
  - 최대 힙: 부모 노드가 항상 자식 노드보다 큰 값을 가지는 이진 트리 
  - 최소 힙: 최대 힙의 반대
- 가능한 가장 적은 공간을 사용하며 최적의 용량을 가짐
- 우선순위 큐 구현, 그래프 순회 알고리즘 등에 사용

### 노드 위치(인덱스) 구하기
- 부모 노드의 인덱스를 기준으로 자식 노드의 위치
  - 2n + 1 - 왼쪽 
  - 2n + 2 - 오른쪽 
- 자식 노드의 인덱스를 기준으로 부모 노드의 위치
  - (n-1) / 2 (소수점은 버림, 내림)

### 힙 시간 복잡도
- 삽입 - O(log n)
- 삭제 - O(log n)
- 탐색 - O(n)

### [우선 순위 큐](src/main/java/trees/PriorityQueue.java) - [Test](src/test/java/trees/PriorityQueueTest.java)
- 각 요소가 우선순위를 가지는 자료 구조
- 높은 우선순위를 먼저 처리
- 힙을 이용하여 구현

