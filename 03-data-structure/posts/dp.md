# 동적 프로그래밍
- 복잡한 문제를 간단한 여러 개의 문제로 나누어 푼 뒤 결과를 결합하여 해결하는 방법
- 부분 문제 반복과 최적 부분 구조를 가지고 있는 알고리즘을 더 빠른 시간 내에 풀기 위해 사용
- 최단 경로 문제, 행렬의 제곱 문제 등의 최적화에 사용

### 부분 문제 반복 (Overlapping sub problems)
- 한 문제를 더 작은 문제들로 나눌 수 있고, 그 조각을 재사용 
- 부분 문제 반복이 아닌 문제 - 병합 정렬 (분할 정복을 사용해서 해결)

### 최적 부분 구조
- 하위 문제들의 최적의 해답을 가지고 최적의 해답을 구할 수 있는 구조

**피보나치 수열은 부분 문제 반복과 최적 부분 구조를 만족한다.**
- 부분 문제 반복
  - fib(5)는 fib(4)와 fib(3)의 하위 문제로 나눌 수 있다
  - fib(4)는 fib(3)과 fib(2)의 하위 문제로 나눌 수 있다.
  - fib(3)는 fib(2)과 fib(1)의 하위 문제로 나눌 수 있다.
  - ... -> 하나의 문제를 더 작은 문제들로 나누고, 나누어진 문제들을 사용하여 상위 문제의 해답을 얻을 수 있다.
- 최적 부분 구조
  - fib(5)의 최적의 해답은 fib(4) + fib(3)이다.
  - fib(4)의 최적의 해답은 fib(3) + fib(2)이다.
  - fib(3)의 최적의 해답은 fib(2) + fib(1)이다.
  - ... -> 하위 문제들의 최적의 해답을 가지고 상위 문제의 최적의 해답을 얻었다.

### 재귀의 문제점
- 피보나치 수열의 가장 간단한 해결법은 재귀를 사용하는 방법
- 시간 복잡도 **O(2^n)** - 성능이 매우 안좋음

## [DynamicPrograming](../src/main/java/dp/DynamicPrograming.java) - [Test](../src/test/java/dp/DynamicProgramingTest.java)

### Memoization
- 이전 계산 값을 메모리에 저장해두어 동일한 계산의 반복 수행을 제거해 시간을 단축하는 기법
- 시간 복잡도 **O(n)**
- 하향식(top down)

### Tabulation
- 하위 문제 결과를 테이블(배열)에 저장 후 루프를 돌면서 다음 문제의 해답을 구하는 방법
- momoization에 비해 직관적이며 메모리를 적게 사용
- 시간 복잡도 **O(n)**
- 상향식(bottom up)